import matplotlib
# Use TkAgg for interactive Tk apps. Must be set BEFORE importing pyplot or any module that imports pyplot.
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg  # noqa: F401
from matplotlib import pyplot as plt  # noqa: F401

import os
import argparse
import sys
import threading
import tkinter as tk
from tkinter import ttk

# Avoid doing build steps on import in other modules; keep it here at app start.
try:
    os.system("python3 build_version.py")
except Exception:
    # Non-fatal; version file may be generated by CI
    pass

from gui.activity_monitor import start_meter_thread, draw_meter
from version import APP_NAME, VERSION, GIT_COMMIT, BUILD_DATE
from gui.layout import create_main_gui
from gui.licenses import setup_licenses_tab
from gui.system_info import setup_system_info_tab
from gui.channel_info import setup_channel_tab
from gui.image_display import attach_image_label, update_image, set_ip, start_screenshot_thread
from gui.scpi_console import setup_scpi_tab
from gui.logging_controls import setup_logging_tab
from gui.marquee import attach_marquee
from gui.power_analysis import setup_power_analysis_tab
from gui.bh_curve import setup_bh_curve_tab
from utils.debug import attach_debug_widget, start_debug_updater, log_debug, set_debug_level
from scpi.waveform import export_channel_csv  # noqa: F401 (used indirectly by tabs)
from scpi.licenses import get_license_options  # noqa: F401 (used by tab)
from scpi.loop import start_scpi_loop
from scpi.data import scpi_data
from scpi.interface import connect_scope, safe_query
from logger.longtime import stop_logging
import app.app_state as app_state
from gui.harmonics_tab import setup_harmonics_tab


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--version", action="store_true", help="Show version number")
    parser.add_argument("--samples", type=int, help="Override number of waveform points (default: 1200)")
    parser.add_argument("--noMarquee", action="store_true", help="Disable the marquee text at the top")
    args = parser.parse_args()

    if args.version:
        print(f"{APP_NAME} {VERSION}")
        print(f"Git Commit: {GIT_COMMIT}")
        print(f"Build Date: {BUILD_DATE}")
        sys.exit(0)

    # Optional override of WAV_POINTS
    if args.samples:
        import config
        config.WAV_POINTS = args.samples
        print(f"üîß Overridden WAV_POINTS to {args.samples}")

    ip = input("Enter RIGOL MSO5000 IP address: ").strip()
    if not ip:
        print("üîå No IP provided")
        return

    scope = connect_scope(ip)
    set_ip(ip)
    scpi_data["ip"] = ip

    if scope:
        try:
            idn = safe_query(scope, "*IDN?")
            os.makedirs("utils", exist_ok=True)
            with open("utils/idn.txt", "w") as f:
                f.write(idn.strip())
            log_debug(f"üìù IDN saved to utils/idn.txt: {idn.strip()}")
        except Exception as e:
            log_debug(f"‚ö†Ô∏è Could not save IDN info to utils/idn.txt: {e}")
        try:
            freq_ref = safe_query(scope, ":POWer:QUALity:FREQreference?", "N/A")
            log_debug(f"üì° Frequency Reference: {freq_ref}")
            scpi_data["freq_ref"] = freq_ref
        except Exception as e:
            log_debug(f"‚ö†Ô∏è Could not get frequency reference: {e}")
    else:
        print("‚ùå Could not connect to scope ‚Äî exiting.")
        return

    # Expose scope globally
    app_state.scope = scope
    app_state.scope_ip = ip

    # Start SCPI loop (kept as-is; uses its own connection)
    start_scpi_loop(ip if ip else "USB")

    # === GUI ===
    root = tk.Tk()
    main_frame = tk.Frame(root, bg="#1a1a1a")
    main_frame.pack(fill="both", expand=True)
    root.title(f"{APP_NAME} {VERSION} [{GIT_COMMIT}] ü¢í {ip}")
    root.geometry("1200x800")
    root.minsize(800, 600)

    # --- Activity Meter ---
    activity_meter = tk.Canvas(main_frame, height=10, bg="#181818", highlightthickness=0)
    activity_meter.pack(fill="x", padx=10, pady=(4, 0))

    meter_state = {"level": 0.0, "phase": 0}
    meter_lock = threading.Lock()
    threading.Thread(target=start_meter_thread, args=(app_state, meter_state, meter_lock), daemon=True).start()

    # Guarded repeating after() with cancel support
    update_meter_after_id = [None]

    def update_meter():
        # Bail out if shutting down or widget was destroyed
        try:
            if getattr(app_state, "is_shutting_down", False):
                return
            if not activity_meter.winfo_exists():
                return
            with meter_lock:
                level = meter_state["level"]
                phase = meter_state["phase"]
            draw_meter(activity_meter, level, phase)
        except tk.TclError:
            return  # likely during teardown
        # Reschedule only if still alive and not shutting down
        try:
            if activity_meter.winfo_exists() and not getattr(app_state, "is_shutting_down", False):
                update_meter_after_id[0] = activity_meter.after(50, update_meter)
        except tk.TclError:
            return

    # Placeholder; replaced after Power tab is created
    power_shutdown = (lambda: None)

    # --- Graceful shutdown: quit mainloop here, destroy after mainloop returns ---
    def shutdown():
        from utils.debug import log_debug
        import app.app_state as app_state

        log_debug("üõë Shutdown requested")

        # Prevent double entry
        if getattr(app_state, "is_shutting_down", False):
            return
        app_state.is_shutting_down = True  # signal all loops/threads to bail early

        # Component-specific cleanup (wrap each in try to avoid cascade failures)
        try:
            power_shutdown()  # your existing power tab cleanup
        except Exception:
            pass

        # BH tab (if present)
        try:
            bh_tab = tabs.get("BH Curve")
            if bh_tab and hasattr(bh_tab, "_shutdown"):
                bh_tab._shutdown()
        except Exception:
            pass

        # Stop long-time logger
        try:
            from logger.longtime import stop_logging
            stop_logging()
        except Exception:
            pass

        # Cancel our local repeating after() for the activity meter
        try:
            if update_meter_after_id[0] is not None:
                activity_meter.after_cancel(update_meter_after_id[0])
                update_meter_after_id[0] = None
        except Exception:
            pass

        # Cancel image updater timer (gui/image_display.py adds this)
        try:
            from gui.image_display import cancel_image_updates
            cancel_image_updates(root)
        except Exception:
            pass

        # Cancel marquee timers
        try:
            if marquee_widget and hasattr(marquee_widget, "_shutdown"):
                marquee_widget._shutdown()
        except Exception:
            pass

        # Stop Tk‚Äôs internal autoscan repeaters (prevents ‚Äú‚Ä¶scroll‚Äù errors)
        try:
            root.tk.call("tk", "cancelrepeat")  # lowercase 'tk' command
        except Exception:
            pass

        # Politely stop the SCPI loop thread if we have a handle to it
        try:
            # If your loop exposes a stop() method, use it; otherwise just join briefly.
            t = getattr(app_state, "scpi_thread", None)
            if t:
                stop_fn = getattr(t, "stop", None)
                if callable(stop_fn):
                    stop_fn()
                t.join(timeout=1.5)
        except Exception:
            pass

        # Quit Tk mainloop; do NOT destroy here (we close VISA after mainloop returns)
        try:
            root.quit()
        except Exception:
            pass


    # Make the WM close button use our shutdown
    root.protocol("WM_DELETE_WINDOW", shutdown)

    # Top Row
    button_row = tk.Frame(main_frame, bg="#1a1a1a")
    button_row.pack(fill="x", padx=10, pady=(5, 0))
    button_row.columnconfigure(0, weight=1)
    button_row.columnconfigure(1, weight=0)

    marquee_frame = tk.Frame(button_row, bg="#1a1a1a")
    marquee_frame.grid(row=0, column=0, sticky="ew")

    button_frame = tk.Frame(button_row, bg="#1a1a1a")
    button_frame.grid(row=0, column=1, sticky="e")

    if not args.noMarquee:
        marquee_widget = attach_marquee(
            marquee_frame,
            file_path="marquee.txt",
            url="https://aether-research.institute/MSO5000/marquee.txt"
        )
    else:
        marquee_widget = None

    toggle_btn = ttk.Button(button_frame, text="üóó Hide", style="TButton")
    toggle_btn.pack(side="left", padx=(10, 5))

    shutdown_btn = ttk.Button(button_frame, text="‚èª Exit", style="TButton", command=shutdown)
    shutdown_btn.pack(side="left", padx=(0, 5))

    # Screenshot area (above tabs)
    img_visible = [True]
    image_frame = tk.Frame(main_frame, bg="#1a1a1a")
    img_label = tk.Label(image_frame, bg="#1a1a1a")
    img_label.pack()

    tabs, notebook = create_main_gui(main_frame, ip)
    image_frame.pack(before=notebook, fill="x", pady=5)

    attach_image_label(img_label)
    update_image(root)
    start_screenshot_thread()

    def toggle_image():
        if img_visible[0]:
            image_frame.pack_forget()
            toggle_btn.config(text="üóñ Show")
        else:
            image_frame.pack(before=notebook, fill="x", pady=5)
            toggle_btn.config(text="üóó Hide")
        img_visible[0] = not img_visible[0]

    toggle_btn.config(command=toggle_image)

    # Tabs
    setup_licenses_tab(tabs["Licenses"], ip, root)
    setup_system_info_tab(tabs["System Info"], root)
    setup_channel_tab(tabs["Channel Data"], ip, root)
    setup_logging_tab(tabs["Long-Time Measurement"], ip, root)
    setup_scpi_tab(tabs["SCPI"], ip)
    setup_power_analysis_tab(tabs["Power Analysis"], ip, root)
    power_tab = tabs["Power Analysis"]
    power_shutdown = getattr(power_tab, "_shutdown", lambda: None)
    setup_bh_curve_tab(tabs["BH Curve"], ip, root)
    bh_tab = tabs["BH Curve"]
    bh_shutdown = getattr(bh_tab, "_shutdown", lambda: None)
    setup_harmonics_tab(tabs["Harmonics/THD"], ip, root)

    # Debug Tab widgets
    debug_frame = tabs["Debug Log"]
    debug_level_frame = tk.Frame(debug_frame, bg="#2d2d2d")
    debug_level_frame.pack(fill="x", padx=5, pady=(5, 0))

    tk.Label(debug_level_frame, text="Debug Output Level:",
             bg="#2d2d2d", fg="#bbbbbb", font=("TkDefaultFont", 9)).pack(side="left", padx=(10, 10))

    tk.Frame(debug_level_frame, bg="#2d2d2d").pack(side="left", expand=True, fill="x")

    debug_var = tk.StringVar(value="FULL")

    def on_debug_level_change():
        set_debug_level(debug_var.get())

    for level, label in [("FULL", "üõ† Full"), ("MINIMAL", "‚ö†Ô∏è Minimal")]:
        tk.Radiobutton(
            debug_level_frame, text=label, variable=debug_var, value=level,
            command=on_debug_level_change,
            bg="#2d2d2d", fg="#ffffff", selectcolor="#555555",
            activebackground="#333333", indicatoron=False,
            relief="raised", width=10
        ).pack(side="left", padx=5)

    text_widget = tk.Text(
        debug_frame, font=("Courier", 9), height=100,
        bg="#1a1a1a", fg="#ffffff", insertbackground="#ffffff",
        selectbackground="#333333", state=tk.DISABLED
    )
    text_widget.pack(side="left", fill="both", expand=True, padx=5, pady=5)
    scrollbar = ttk.Scrollbar(debug_frame, orient="vertical", command=text_widget.yview)
    text_widget.configure(yscrollcommand=scrollbar.set)
    scrollbar.pack(side="right", fill="y")
    attach_debug_widget(text_widget)
    start_debug_updater(root)
    log_debug("üîß Debug log ready.")

    # Kick off guarded meter loop
    update_meter()

    # Run GUI; destroy AFTER loop ends (prevents 'invalid command name ... after script')
    try:
        root.mainloop()
    finally:
        try:
            # Close our primary scope handle last
            from scpi.interface import scpi_lock
            with scpi_lock:
                if app_state.scope:
                    try:
                        app_state.scope.close()
                    except Exception:
                        pass
                    app_state.scope = None
        except Exception:
            pass
        try:
            root.destroy()
        except Exception:
            pass

if __name__ == "__main__":
    main()